#!/usr/bin python3

import numpy as np

from mpclab_strategy_obca.control.abstractController import abstractController

from mpclab_strategy_obca.control.utils.types import trackingParams

from mpclab_strategy_obca.dynamics.dynamicsModels import bike_dynamics_rk4

# ====== Hacky: Import the solve methods from solvers generated by MATLAB client
from mpclab_strategy_obca.control.utils.tracking_solver.interface.tracking_solver_py import tracking_solver_solve

import pdb

class MatlabFPSolver(object):
	"""
	Wrapper class for the FP solver object generated by MATLAB
	"""
	def __init__(self, solve_method):
		self.solve_method = solve_method

	def solve(self, problem):
		return self.solve_method(problem)
# ========

class trackingController(abstractController):
	def __init__(self, dynamics, params=trackingParams()):
		self.dynamics = dynamics

		self.dt = params.dt

		self.n_x = params.n
		self.n_u = params.d

		self.N = params.N

		self.Q = params.Q
		self.R = params.R
		self.R_d = params.R_d

		self.z_l = params.z_l
		self.z_u = params.z_u
		self.u_l = params.u_l
		self.u_u = params.u_u
		self.du_l = params.du_l
		self.du_u = params.du_u

		self.optlevel = params.optlevel

	def initialize(self, regen=False):

		self.tracking_solver = MatlabFPSolver(tracking_solver_solve)

	def solve(self, z_s, u_prev, z_ref, z_ws, u_ws):
		x0 = []
		params = []
		ub = []
		lb = []

		for k in range(self.N+1):
			if k == self.N:
				x0.append(z_ws[k, :])
				ub.append(self.z_u)
				lb.append(self.z_l)
				params.extend((z_ref[k, :], self.Q))
			elif k == 0:
				x0.extend((z_ws[k, :], u_ws[k, :], u_prev))
				ub.append(self.u_u)
				lb.append(self.u_l)
				params.extend((z_ref[k, :], self.Q, self.R, self.R_d))
			else:
				x0.extend((z_ws[k, :], u_ws[k, :], u_ws[k, :]))
				ub.extend((self.z_u, self.u_u, self.u_u))
				lb.extend((self.z_l, self.u_l, self.u_l))
				params.extend((z_ref[k, :], self.Q, self.R, self.R_d))

		problem = {"x0": np.hstack(x0),
					"all_parameters": np.hstack(params),
					"xinit": np.hstack((z_s, u_prev)),
					"ub": np.hstack(ub),
					"lb": np.hstack(lb)}

		output, exitflag, info = self.tracking_solver.solve(problem)

		if exitflag == 1:
			print("TRACKING: FORCES took %d iterations and %f seconds to solve the problem." % (info.it,info.solvetime))
			status = {"success": True,
						"return_status": "Successfully Solved",
						"solve_time": info.solvetime,
						"info": info}
		else:
			print("TRACKING: Solving Failed, exitflag = %d\n" % exitflag)
			status = {"success": False,
						"return_status": 'Solving Failed, exitflag = %d' % exitflag,
						"solve_time": None,
						"info": info}

		z_pred = np.zeros((self.N+1, self.n_x))
		u_pred = np.zeros((self.N, self.n_u))

		for k in range(self.N):
			sol = output["x%02d" % (k+1)]
			z_pred[k, :] = sol[:self.n_x]
			u_pred[k, :] = sol[self.n_x : self.n_x + self.n_u]

		sol = output["x%02d" % (self.N+1)]
		z_pred[self.N, :] = sol[:self.n_x]

		return z_pred, u_pred, status


def main():
	dynamics = bike_dynamics_rk4()
	params = trackingParams()
	controller = trackingController(dynamics, params)
	controller.initialize()

	# Generate fake obs and hyp to test the solver
	z_ws = np.zeros((51, 4))
	u_ws = np.zeros((50, 2))

	z_s = np.zeros(4)
	u_prev = np.zeros(2)
	z_ref = np.zeros((51, 4))

	controller.solve(z_s, u_prev, z_ref, z_ws, u_ws)

if __name__ == '__main__':
	main()
